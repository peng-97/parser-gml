{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["const parseOption = { shape: [\"geometry\", \"the_geom\", \"geom\", \"shape\"] };\r\nfunction getPoint(point, type) {\r\n  let coor = point.split(type).map(function (co) {\r\n    return parseFloat(co);\r\n  });\r\n  return {\r\n    type: \"Point\",\r\n    coordinates: coor,\r\n  };\r\n}\r\nfunction getGeoJsonPoint(data) {\r\n  let key = Object.keys(data)[0];\r\n  return key == \"pos\" ? getPoint(data[key], \" \") : getPoint(data[key], \",\");\r\n}\r\nfunction getGeoJsonPolyline(data) {\r\n  let key = Object.keys(data)[0];\r\n  let polyline = [];\r\n  if (key == \"posList\") {\r\n    let listcoor = data[key].split(\" \");\r\n    listcoor.forEach(function (co, index) {\r\n      if (index % 2 != 0) {\r\n        polyline.push([\r\n          Number.parseFloat(listcoor[index - 1]),\r\n          Number.parseFloat(listcoor[index]),\r\n        ]);\r\n      }\r\n    });\r\n  } else {\r\n    data[key].split(\" \").map(function (point) {\r\n      polyline.push(getPoint(point, \",\").coordinates);\r\n    });\r\n  }\r\n  return {\r\n    type: \"LineString\",\r\n    coordinates: polyline,\r\n  };\r\n}\r\nfunction getGeoJsonPolygon(data) {\r\n  let key = Object.keys(data)[0];\r\n  let polygon = [];\r\n  if (data[key] instanceof Array) {\r\n    data[key].forEach(function (lineArea) {\r\n      polygon.push(\r\n        getGeoJsonPolyline(lineArea[Object.keys(lineArea)[0]]).coordinates\r\n      );\r\n    });\r\n  } else {\r\n    polygon.push(\r\n      getGeoJsonPolyline(data[key][Object.keys(data[key])[0]]).coordinates\r\n    );\r\n  }\r\n  return {\r\n    type: \"Polygon\",\r\n    coordinates: polygon,\r\n  };\r\n}\r\nfunction convertToJSON(xmlDoc) {\r\n  // xmlDoc =new DOMParser().parseFromString(xmlDoc, 'text/xml');\r\n  var nodeList = xmlDoc.childNodes; //根节点  root node\r\n  function generate(node_list) {\r\n    let obj = {};\r\n    let childNodes = getNodeChildName(node_list);\r\n    for (var i = 0; i < node_list.length; i++) {\r\n      var curr_node = node_list[i];\r\n      if (curr_node.nodeType == 3) {\r\n        //忽略子节点中的换行和空格   ignore  '\\n' and ' ' of  children node\r\n        continue;\r\n      }\r\n      let value = \"\"; // let value= curr_node.childNodes.length > 1 ? generate(curr_node.childNodes): (curr_node.childNodes[0]!=null?curr_node.childNodes[0].nodeValue.trim():\"\");\r\n      if (curr_node.childNodes.length > 1) {\r\n        value = generate(curr_node.childNodes);\r\n      } else if (curr_node.childNodes.length == 1) {\r\n        value = curr_node.childNodes[0].nodeValue\r\n          ? curr_node.childNodes[0].nodeValue.trim()\r\n          : generate(curr_node.childNodes);\r\n      }\r\n      let key = curr_node.nodeName.substring(\r\n        curr_node.nodeName.indexOf(\":\") + 1\r\n      );\r\n      if (childNodes[curr_node.nodeName] > 1) {\r\n        if (obj[key]) {\r\n          obj[key].push(value);\r\n        } else {\r\n          obj[key] = [value];\r\n        }\r\n      } else {\r\n        obj[key] = value;\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n  //find children node name from father node\r\n  function getNodeChildName(node_list) {\r\n    let obj = {};\r\n    for (var i = 0; i < node_list.length; i++) {\r\n      var curr_node = node_list[i];\r\n      if (curr_node.nodeType == 3) {\r\n        continue;\r\n      }\r\n      let name = node_list[i].nodeName;\r\n      obj[name] = obj.hasOwnProperty(name) ? obj[name] + 1 : 1;\r\n    }\r\n    return obj;\r\n  }\r\n  return generate(nodeList);\r\n}\r\nfunction getMutiGeometry(data) {\r\n  let key = Object.keys(data)[0];\r\n  if (data[key] instanceof Array) {\r\n    let listGeometry = data[key].map(function (po) {\r\n      return getGeometry(po);\r\n    });\r\n    return {\r\n      type: \"Multi\" + listGeometry[0].type,\r\n      coordinates: listGeometry.map(function (geo) {\r\n        return geo.coordinates;\r\n      }),\r\n    };\r\n  } else if (data[key] instanceof Object) {\r\n    let geometry = getGeometry(data[key]);\r\n    return {\r\n      type: \"Multi\" + geometry.type,\r\n      coordinates: [geometry.coordinates],\r\n    };\r\n  } else {\r\n    {\r\n    }\r\n  }\r\n}\r\nfunction getGeometry(data) {\r\n  let key = Object.keys(data)[0];\r\n  switch (key.toLowerCase()) {\r\n    case \"point\":\r\n      return getGeoJsonPoint(data[Object.keys(data)[0]]);\r\n    case \"linestring\":\r\n      return getGeoJsonPolyline(data[Object.keys(data)[0]]);\r\n    case \"polygon\":\r\n      return getGeoJsonPolygon(data[Object.keys(data)[0]]);\r\n    default:\r\n      return getMutiGeometry(data[Object.keys(data)[0]]);\r\n  }\r\n}\r\nfunction parseFeature(feature) {\r\n  var obj = {\r\n    type: \"Feature\",\r\n    geometry: {},\r\n    properties: {},\r\n  };\r\n  let geometry = null;\r\n  for (var pKey in feature) {\r\n    !parseOption.shape.find(function (geo) {\r\n      return pKey.toLowerCase() == geo;\r\n    })\r\n      ? (obj.properties[pKey] = feature[pKey])\r\n      : (geometry = feature[pKey]);\r\n  }\r\n  if (geometry) {\r\n    obj.geometry = getGeometry(geometry);\r\n  } else {\r\n    //no shape fields,select fields from data and construct object\r\n    for (var pKey in obj.properties) {\r\n      if (\r\n        obj.properties[pKey] instanceof Object ||\r\n        obj.properties[pKey] instanceof Array\r\n      ) {\r\n        obj.geometry = getGeometry({ shape: obj.properties[pKey] });\r\n        delete obj.properties[pKey];\r\n      }\r\n    }\r\n  }\r\n  return obj;\r\n}\r\nfunction parseMember(data) {\r\n  let features = [];\r\n  if (data instanceof Array) {\r\n    data.forEach(function (feature) {\r\n      features.push(parseFeature(feature));\r\n    });\r\n  } else if (data instanceof Object) {\r\n    features.push(parseFeature(data));\r\n  }\r\n  return features;\r\n}\r\nfunction getGeoJson(data, option) {\r\n  if (!data) {\r\n    return null;\r\n  }\r\n  if (option && option.shape) {\r\n    parseOption.shape.push(option.shape.toLowerCase());\r\n  }\r\n  let features = [];\r\n  try {\r\n    if (Object.prototype.toString.call(data) != \"[object XMLDocument]\") {\r\n      data = new DOMParser().parseFromString(data, \"text/xml\");\r\n    }\r\n    let jsonData = convertToJSON(data);\r\n    let featurecollection = jsonData[Object.keys(jsonData)[0]];\r\n    let key = Object.keys(featurecollection).find(function (type) {\r\n      return type.toLowerCase().includes(\"member\");\r\n    });\r\n    let members = featurecollection[key];\r\n    // if(key.toLowerCase().includes(\"members\")){\r\n    //     if (members instanceof Array) {\r\n    //         members.forEach(function (member) {\r\n    //             features=  features.concat(parseMember(member[Object.keys(member)[0]]))\r\n    //         })\r\n    //     } else if (members instanceof Object) {\r\n    //         features=features.concat(parseMember(members[Object.keys(members)[0]]))\r\n    //     }\r\n    // } else{\r\n    //     if (members instanceof Array) {\r\n    //         members.forEach(function (member) {\r\n    //             features.push(parseFeature(member[Object.keys(member)[0]]))\r\n    //         })\r\n    //     } else if (members instanceof Object) {\r\n    //         let member=members[Object.keys(members)[0]];\r\n    //         features.push(parseFeature( member))\r\n    //     }\r\n    // }\r\n    if (members instanceof Array) {\r\n      members.forEach(function (member) {\r\n        features = features.concat(parseMember(member[Object.keys(member)[0]]));\r\n      });\r\n    } else if (members instanceof Object) {\r\n      features = features.concat(parseMember(members[Object.keys(members)[0]]));\r\n    }\r\n    return {\r\n      type: \"FeatureCollection\",\r\n      features,\r\n    };\r\n  } catch (er) {\r\n    console.log(er);\r\n    return null;\r\n  }\r\n}\r\nexports.getGeoJson = getGeoJson;\r\n"],"names":["parseOption","shape","getPoint","point","type","coordinates","split","map","co","parseFloat","getGeoJsonPolyline","data","key","Object","keys","polyline","listcoor","forEach","index","push","Number","getGeometry","toLowerCase","getGeoJsonPoint","polygon","Array","lineArea","getGeoJsonPolygon","listGeometry","po","geo","geometry","getMutiGeometry","parseFeature","feature","obj","properties","pKey","find","parseMember","features","getGeoJson_1","option","prototype","toString","call","DOMParser","parseFromString","jsonData","generate","node_list","childNodes","i","length","nodeType","name","nodeName","hasOwnProperty","getNodeChildName","curr_node","value","nodeValue","trim","substring","indexOf","featurecollection","members","includes","member","concat","er","console","log"],"mappings":"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"}